## 4-3 型の合成

- 関数型プログラミングでは「合成(コンポジション)」が関数型設計の基本になる
- 合成は新しい関数や型を作るために用いられる

### 4-3-1 AND型

- F#でば「Apple, Banana, Cherries」を持つ型、として新しい型を作ることができる
- F#ではこれをAND型と呼び、AND型で定義したものを「レコード」と呼ぶ

```F#
type FruitSalad = {
    Apple: AppleVeriety
    Banana: BananaVeriety
    Cherries: CherriesVeriety
}
```
- F#でいう「レコード」をgoでは「構造体」と呼ぶ

```go
type FruitSalad struct {
    AppleVeriety Apple
    BananaVeriety Banana
    CherriesVeriety Cherries
}
```

### 4-3-2 OR型

- F#では「Apple, Banana, Cherries」のいずれかを持つ型、のような新しい型を作ることができる
- F#ではこれをOR型と呼び、OR型で定義したものを「判別共用体」と呼ぶ

```F#
type FruitSnack =
  | Apple of AppleVeriety
  | Banana of BananaVeriety
  | Cherries or CherriesVeriety
```

- goには「判別共用体」のような概念は存在しない?(知ってたら教えてください)
- goのインターフェースを用いて似たような定義することは可能かなと思います

```go
package main

type FruitSnack interface {
    Flavor() string
}

type Apple struct{
    AppleVeriety Apple
}

func (a Apple) Flavor() string {
    // AppleVerietyがflavorの値を持っていると仮定
    return Apple.AppleVeriety.flavor
}

type Banana struct{
    BananaVeriety Banana
}

func (b Banana) Flavor() string {
    // BananaVerietyがflavorの値を持っていると仮定
    return Banana.BananaVeriety.flavor
}

func main() {
    fruitsnack := FruitSnack{Apple{}}
    fruitsnack.Flavor()
}
```

### 4-3-3 単純型

- 関数型プログラミングでは選択肢が1つしかない「判別共用体」を定義することがある
- 本書ではこれを「単純型」と呼ぶ
- 単純型を定義することでプリミティブな型に対して名前をつけることができる(型エイリアスのようなもの?)

```F#
type ProductCode = ProductCode of string
```

- goなら以下のような感じになるかなと思います

```go
type ProductCode string
```

### 4-3-4 代表的な型システム

- 代表的な型システムとは全ての複合型がより小さな型からANDまたはORで構成される型のこと